<!DOCTYPE html>
<head>
	

</head>
<body>
	<canvas id="canvas" />
	<div id="your-files"></div>
	<script type="text/javascript">
	

	canvas.width = window.innerWidth-30;
	canvas.height = window.innerHeight-30;
	
	if (canvas.width>1000){
		var canvasstart=20
		var canvasend=canvas.width-20
	}
	else {
		var canvasstart=canvas.width/50
		var canvasend=canvas.width-(canvas.width/50)
	}
	
	var canvaslength=canvasend-canvasstart
	
	var genomelength=50000
	
	var scale=1
	var start=0
	var end=genomelength
	var xscalingfactor=canvaslength/(end-start)
	
	var genome_track_height=100
	var top_padding=50
	var left_padding=50
	var right_padding=50
	var gap_to_scale=4

	
	var scalepos=(genome_track_height+top_padding)/2
	
	var recombinations=[];
	
	var heatmap_blocks=[];
	
	Array.prototype.contains = function(obj) {
    var i = this.length;
    while (i--) {
        if (this[i] === obj) {
            return i;
        }
    }
    return -1;
	}
	
	function drawScale(ctx, xstart, xend, numticks) {
			
		numticks = numticks || 6;
		
		ctx.strokeStyle="black";
		ctx.lineWidth=1;
		ctx.beginPath();
		ctx.moveTo(xstart, scalepos);
		ctx.lineTo(xend, scalepos);
		ctx.stroke();
		
		var tickdistance=((end-start)/(numticks-1));
		
		for(ticknum= 0; ticknum < numticks; ticknum++){
			var tickpos=((xend-xstart)/(numticks-1))*ticknum;
			var tickval=(((end-start)/(numticks-1))*ticknum)+start;
			if (tickval>=1000000) {
				
				tickval=tickval/1000000
				
				var tmptickdistance=tickdistance/1000000;
				var roundto=2
				
				while (tmptickdistance<0.01) {
					roundto+=1
					tmptickdistance=10*tmptickdistance
				}
				tickval=String(+ tickval.toFixed(roundto))+"M";
				
				}
			else if (tickval>=1000) {
				
				tickval=tickval/1000
				tickval=String(+ tickval.toFixed(2))+"k";
				}
			else {
				tickval=String(+ tickval.toFixed(2));
				}
			
			ctx.beginPath();
			ctx.moveTo(xstart+tickpos, scalepos);
			ctx.lineTo(xstart+tickpos, scalepos+10);
			ctx.stroke();
			ctx.save();
			ctx.translate( xstart+tickpos, scalepos+10 );
			ctx.fillStyle = "black";
			ctx.textBaseline="middle";
			ctx.textAlign = "left";
			ctx.rotate(Math.PI*0.5);
			ctx.font="12px Helvetica";
  			ctx.fillText(tickval, 0, 0);
  			ctx.restore();
			
		}
	}
	
	
	
	function Block(featurestart, featureend, fill, fillAlpha, stroke, strokeWidth, info){
		// This is a very simple and unsafe constructor. 
		// All we're doing is checking if the values exist.
		// "x || 0" just means "if there is a value for x, use that. Otherwise use 0."
		this.fill = fill || '#AAAAAA';
		this.fillAlpha = fillAlpha || 1;
		this.stroke = stroke || 'black';
		this.strokeWidth = strokeWidth || 0;
		this.info = info || '';
		this.featurestart = featurestart || 0
		this.featureend = featureend || 0
		this.x = 0;
		this.y = 150;
		this.w = 1;
		this.h = 30;
	}
	
	
	// Sets the x and w of the block feature
	Block.prototype.set_xw = function() {
		
		this.x=xscalingfactor*(this.featurestart-start)+canvasstart;
		this.w=xscalingfactor*(this.featureend-this.featurestart);
		
		
	}

	
	// Draws this block to a given context
	Block.prototype.draw = function(ctx) {
		
		if (((this.featureend)<start) || (this.featurestart>end)){
			return;	
		}
		else
		ctx.beginPath();
		ctx.fillStyle = this.fill;
		ctx.strokeStyle = this.stroke;
		ctx.lineWidth = this.strokeWidth;
		
		var cutstart=false;
		var cutend=false;
		
		if (this.x<canvasstart){	
			blockstart=canvasstart;
			blocklength=this.w-(canvasstart-this.x)
			cutstart=true;
		}
		else {	
			blockstart=this.x
			blocklength=this.w
		}
		if (this.x+this.w>canvasend){	
			blocklength=canvasend-blockstart;
			cutend=true;
		}
		else {	
			blocklength=blocklength
		}
		
		ctx.rect(blockstart, this.y, blocklength, this.h)
		ctx.closePath();
		ctx.fill();
		
		ctx.setLineDash([2,2])
		if (cutstart){
			ctx.beginPath();
			
			ctx.moveTo(canvasstart, this.y);
			ctx.lineTo(canvasstart, this.y+this.h);
			ctx.stroke();	
		}
		if (cutend){
			ctx.beginPath();
			ctx.moveTo(canvasend, this.y);
			ctx.lineTo(canvasend, this.y+this.h);
			ctx.stroke();	
		}
		ctx.setLineDash([])
		
		
		if (this.strokeWidth>0){
			ctx.stroke();
		}
	}
	
	function sortarrayofarraysNumber(a,b)
	{
		return a[0] - b[0];
	}
	
	
	function rgbToHex(R,G,B) {return "#"+toHex(R)+toHex(G)+toHex(B)}
	function toHex(n) {
	 n = parseInt(n,10);
	 if (isNaN(n)) return "00";
	 n = Math.max(0,Math.min(n,255));
	 return "0123456789ABCDEF".charAt((n-n%16)/16)
	      + "0123456789ABCDEF".charAt(n%16);
	}
	
	
	function ConvertBlockstoHeat(myblocks){
		
		var sort_order=[];
		
		for (i=0; i<myblocks.length; i++){	
			
			sort_order.push([myblocks[i][0], 0, i]);
			sort_order.push([myblocks[i][1], 1, i]);
			
		}
		
		sort_order=sort_order.sort(sortarrayofarraysNumber);
		
		var heatblocks=[];
		var heat_depth=0;
		var blockstart=0;
		var maxdepth=0;
		
		for (i=0; i<sort_order.length; i++){
			
			
			if (heat_depth>0) {
				heatblocks.push([blockstart, sort_order[i][0], heat_depth])	
			}
			
			
			if (sort_order[i][1]==0){
			
				heat_depth+=1
				
				if (heat_depth>maxdepth){
					maxdepth=heat_depth;	
				}
				
				blockstart=sort_order[i][0]
				
			}
			else if (sort_order[i][1]==1){
			
				heat_depth-=1
				blockstart=sort_order[i][0]
				
			}
			
		}
		
		
		for (i=0; i<heatblocks.length; i++){
			var depth=heatblocks[i][2];
			heatblocks[i].splice(2,1);
			heatblocks[i].push(rgbToHex(((depth-1)/(maxdepth-1))*255,0,255-(((depth-1)/(maxdepth-1))*255)))	
		}
		
		
		
		return heatblocks;
		
	}
	
	
	
	function calculateBlockDepthPlot(myblocks){
		
		var sort_order=[];
		
		for (i=0; i<myblocks.length; i++){	
			
			sort_order.push([myblocks[i].featurestart, 0, i]);
			sort_order.push([myblocks[i].featureend, 1, i]);
			
		}
		
		sort_order=sort_order.sort(sortarrayofarraysNumber);
		
		var drawpoints=[];
		var depth=0;
		
		drawpoints.push([0, depth])
		
		for (i=0; i<sort_order.length; i++){
			
			drawpoints.push([sort_order[i][0], depth])
			if (sort_order[i][1]==0){
			
				depth+=1;
				
				
			}
			else if (sort_order[i][1]==1){
			
				depth-=1;
				
			}
			
			drawpoints.push([sort_order[i][0], depth])
			
		}
		
		drawpoints.push([genomelength, depth])
		
		return drawpoints;
		
		
	}
	
	
	function drawBlockDepthPlot(ctx, drawpoints){
	
		
		var maxdepth=0;
		var plotheight=50
		ctx.strokeStyle = "black";
		ctx.fillStyle = "black";
		ctx.lineWidth = 1;
		ctx.beginPath();
		var startval=0;
		var endval=0;
		
		for (i=0; i<drawpoints.length; i++){
			
			if (((drawpoints[i][0])>=start) && (drawpoints[i][0]<=end)){
				
				if (drawpoints[i][1]>maxdepth) {
					maxdepth=drawpoints[i][1];
				}
			}
			else if (drawpoints[i][0]<start){
				if (i+1<drawpoints.length){
					startval=drawpoints[i+1][1];
				}
			}
			
		}
		
		ctx.moveTo(canvasstart, 300);
		ctx.lineTo(canvasstart, 300-((startval/maxdepth)*plotheight));
		
		for (i=0; i<drawpoints.length; i++){
			
			if (((drawpoints[i][0])>=start) && (drawpoints[i][0]<=end)){
				
				ctx.lineTo((xscalingfactor*(drawpoints[i][0]-start))+canvasstart, 300-((drawpoints[i][1]/maxdepth)*plotheight));
				endval=drawpoints[i][1];
			}
			
		}
		
		if (endval!=0){
			ctx.lineTo(canvasend, 300-((endval/maxdepth)*plotheight));
		}
		ctx.lineTo(canvasend, 300);
		ctx.closePath();
		ctx.stroke();
		ctx.fill();
		ctx.beginPath();
		ctx.moveTo(canvasstart, 300);
		ctx.lineTo(canvasstart, 300-plotheight);
		ctx.lineTo(canvasstart-2, 300-plotheight);
		ctx.stroke();
		ctx.save();
		ctx.translate( canvasstart+2, 300-plotheight);
		ctx.textAlign = "left";
		ctx.textBaseline="middle";
		ctx.font="12px Helvetica";
 		ctx.fillText(String(maxdepth), 0, 0);
		ctx.restore();
		
		
		
	}
	
	
	

	function Arrow(featurestart, featureend, direction, fill, stroke, strokeWidth, info){
		// This is a very simple and unsafe constructor. 
		// All we're doing is checking if the values exist.
		// "x || 0" just means "if there is a value for x, use that. Otherwise use 0."
		this.direction = direction || 'None';
		this.fill = fill || '#AAAAAA';
		this.stroke = stroke || 'black';
		this.strokeWidth = strokeWidth || 1;
		this.info = info || '';
		this.featurestart = featurestart || 0
		this.featureend = featureend || 0
		this.x = 0;
		this.y = 0;
		this.w = 1;
		this.h = 20;
		this.coordinates = [];
		
		this.ID = "";
		this.product="";
		this.locus_tag="";
		
		var infoparts=this.info.split(";");
		//console.log(infoparts);
		for (i=0; i<infoparts.length; i++){
				var varval=infoparts[i].split("=");
				if (varval.length<2) {
					continue;
				}
				var variable=varval[0].replace(/(^"|"$)/g, '');
				var value=varval[1].replace(/(^"|"$)/g, '')
				if (variable=="ID") {
					 this.ID=value;
					 }
				else if (variable=="product") {
					this.product=value.replace(/(^"|"$)/g, '');
					}
				else if (variable=="locus_tag") {
					this.locus_tag=value.replace(/(^"|"$)/g, '');
					}
		}
		
		
	}
		
		
	// Sets the coordinates of the arrow feature
	Arrow.prototype.set_coordinates = function() {
		
		this.x=xscalingfactor*(this.featurestart-start)+canvasstart;
		this.w=xscalingfactor*(this.featureend-this.featurestart);
		
		if (this.w>20){
			var point_length=10;
			var arrowtype="arrow";
		}
		else {var arrowtype="rectangle";}
		
		
		
		if (this.direction=="+"){
			ymin=scalepos-(this.h+gap_to_scale)
		}
		else if (this.direction=="-"){
			ymin=scalepos+gap_to_scale
		}
		else{
			ymin=scalepos-(this.h/2)
		}
		
		this.y=ymin
		this.coordinates=[]
		if (this.direction=="+" && arrowtype=="arrow") {
			this.coordinates.push([this.x, this.y+this.h]);
			this.coordinates.push([(this.w-point_length)+this.x, this.y+this.h]);
			this.coordinates.push([this.w+this.x, (this.h/2)+this.y]);
			this.coordinates.push([(this.w-point_length)+this.x, this.y]);
			this.coordinates.push([this.x, this.y]);
		}
		else if (this.direction=="-" && arrowtype=="arrow") {
			this.coordinates.push([this.x+(point_length), this.y]);
			this.coordinates.push([this.w+this.x, this.y]);
			this.coordinates.push([this.w+this.x, this.y+this.h]);
			this.coordinates.push([this.x+(point_length), this.y+this.h]);
			this.coordinates.push([this.x, (this.h/2)+this.y]);
		}
		else {
			this.coordinates.push([this.x, this.y]);
			this.coordinates.push([this.x, this.y+this.h]);
			this.coordinates.push([this.x+this.w, this.y+this.h]);
			this.coordinates.push([this.x+this.w, this.y]);
		}
		
	}
	
	
	// Draws this arrow to a given context
	Arrow.prototype.draw = function(ctx) {
		
		if ((this.w<0.1) || ((this.featureend)<start) || (this.featurestart>end)){
			return;	
		}
		
		ctx.fillStyle = this.fill;
		ctx.strokeStyle = this.stroke;
		ctx.lineWidth = this.strokeWidth;
		var cutstart=false;
		var cutend=false;
		
		if (this.coordinates.length<2) {
			return;	
		}
		ctx.beginPath();
		
		
		if (this.featurestart<start){
			cutstart=true;	
		}
		
		
		if (this.featureend>end){
			cutend=true;	
		}
		
		if (this.coordinates[0][0]<canvasstart){
			ctx.moveTo(canvasstart, this.coordinates[0][1]);
		}
		else if (this.coordinates[0][0]>canvasend){
			ctx.moveTo(canvasend, this.coordinates[0][1]);
		}
		else {
			ctx.moveTo(this.coordinates[0][0], this.coordinates[0][1]);
		}
		
		for (var i = 1; i < this.coordinates.length; i++) {
			if (this.coordinates[i][0]<canvasstart){
				ctx.lineTo(canvasstart, this.coordinates[i][1]);
			}
			else if (this.coordinates[i][0]>canvasend){
				ctx.lineTo(canvasend, this.coordinates[i][1]);
			}
			else {
				ctx.lineTo(this.coordinates[i][0], this.coordinates[i][1]);
			}
		}
		ctx.closePath();
		ctx.fill();
		//if (this.w>3){
		//	ctx.stroke();
		//}
		ctx.setLineDash([2,2])
		if (cutstart){
			ctx.beginPath();
			
			ctx.moveTo(canvasstart, this.y);
			ctx.lineTo(canvasstart, this.y+this.h);
			ctx.stroke();	
		}
		if (cutend){
			ctx.beginPath();
			ctx.moveTo(canvasend, this.y);
			ctx.lineTo(canvasend, this.y+this.h);
			ctx.stroke();	
		}
		ctx.setLineDash([])
	}
	
	
	
	// Determine if a point is inside the arrow's bounds
	Arrow.prototype.contains = function(mx, my) {
		// All we have to do is make sure the Mouse X,Y fall in the area between
		// the arrow's X and (X + Width) and its Y and (Y + Height)
		return (this.x <= mx) && (this.x + this.w >= mx) &&
		(this.y <= my) && (this.y + this.h >= my);
	}
	
	
	
	function CanvasState(canvas) {
	// **** First some setup! ****
	
	
		this.canvas = canvas;
		this.width = canvas.width;
		this.height = canvas.height;
		this.ctx = canvas.getContext('2d');
		// This complicates things a little but but fixes mouse co-ordinate problems
		// when there's a border or padding. See getMouse for more detail
		var stylePaddingLeft, stylePaddingTop, styleBorderLeft, styleBorderTop;
		if (document.defaultView && document.defaultView.getComputedStyle) {
		this.stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingLeft'], 10) || 0;
		this.stylePaddingTop = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingTop'], 10) || 0;
		this.styleBorderLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderLeftWidth'], 10) || 0;
		this.styleBorderTop = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderTopWidth'], 10) || 0;
		}
		// Some pages have fixed-position bars (like the stumbleupon bar) at the top or left of the page
		// They will mess up mouse coordinates and this fixes that
		var html = document.body.parentNode;
		this.htmlTop = html.offsetTop;
		this.htmlLeft = html.offsetLeft;
		// **** Keep track of state! ****
		this.valid = true; // when set to false, the canvas will redraw everything
		this.arrows = []; // the collection of things to be drawn
		this.blocks = []; // the collection of things to be drawn
		this.heatblocks = []; // the collection of things to be drawn
		this.depths = []; // the collection of things to be drawn
		this.dragging = false; // Keep track of when we are dragging
		// the current selected object. In the future we could turn this into an array for multiple selection
		this.selection = [];
		this.dragoffx = 0; // See mousedown and mousemove events for explanation
		this.dragoffy = 0;
		// **** Then events! ****
		// This is an example of a closure!
		// Right here "this" means the CanvasState. But we are making events on the Canvas itself,
		// and when the events are fired on the canvas the variable "this" is going to mean the canvas!
		// Since we still want to use this particular CanvasState in the events we have to save a reference to it.
		// This is our reference!
		var myState = this;
	
		//fixes a problem where double clicking causes text to get selected on the canvas
		canvas.addEventListener('selectstart', function(e) { e.preventDefault(); return false; }, false);
		
	
		canvas.addEventListener('mousedown', function(e) {
		    vardragStart = e.clientX;
		    var mouse = myState.getMouse(e);
			var mx = mouse.x;
			var my = mouse.y;
			var ctrlPressed=0;
			var altPressed=0;
			var shiftPressed=0;
			
			if (parseInt(navigator.appVersion)>3) {

			var evt = e ? e:window.event;
			
			if (document.layers && navigator.appName=="Netscape"
			      && parseInt(navigator.appVersion)==4) {
			   // NETSCAPE 4 CODE
			   var mString =(e.modifiers+32).toString(2).substring(3,6);
			   shiftPressed=(mString.charAt(0)=="1");
			   ctrlPressed =(mString.charAt(1)=="1");
			   altPressed  =(mString.charAt(2)=="1");
			   self.status="modifiers="+e.modifiers+" ("+mString+")"
			}
			else {
			   // NEWER BROWSERS [CROSS-PLATFORM]
			   shiftPressed=evt.shiftKey;
			   altPressed  =evt.altKey;
			   ctrlPressed =evt.ctrlKey;
			   self.status=""
			    +  "shiftKey="+shiftPressed 
			    +", altKey="  +altPressed 
			    +", ctrlKey=" +ctrlPressed 
			}
			  
			}
			
			
			var arrows = myState.arrows;
			myState.dragoffx = mx;
			myState.dragoffy = my;
			myState.dragging = true;
			var l = arrows.length;
			for (var i = l-1; i >= 0; i--) {
				var mySel = arrows[i];
				if (arrows[i].contains(mx, my)) {
					// Keep track of where in the object we clicked
					// so we can move it smoothly (see mousemove)
					if (shiftPressed){
						
						var myindex=myState.selection.contains(mySel)
						
						if (myindex>-1){
							myState.selection.splice(myindex, 1);
						}
						else{
							myState.selection.push(mySel);
						}
					}
					else{
						myState.selection = [mySel];
					}
					myState.valid = false;
					return;
				}
			}
			
			
			// havent returned means we have failed to select anything.
			// If there was an object selected, we deselect it
			if (myState.selection.length>0) {
				myState.selection = [];
				
				myState.valid = false; // Need to clear the old selection border
			}
		}, true);
		
		
		
		canvas.addEventListener('mouseup', function(e) {
			myState.dragging = false;
		}, true);
		
		
		canvas.addEventListener ("mouseout", function(e) {
			myState.dragging = false;
		}, true);
		
		canvas.addEventListener('mousemove', function(e) {
			if (myState.dragging){
				var mouse = myState.getMouse(e);
				// We don't want to drag the object by its top-left corner, we want to drag it
				// from where we clicked. Thats why we saved the offset and use it here
				var mx = mouse.x;
				var my = mouse.y;
				var dragOffsetx = mx - myState.dragoffx;
				var dragOffsety = my - myState.dragoffy;
				
				var length=end-start
				
				var dragproportionx=(dragOffsetx/canvaslength)*length
				
				if (((start-dragproportionx)>0) && ((end-dragproportionx)<genomelength)) { 
					start=(start-dragproportionx);
					end=(end-dragproportionx);
				}
				else if ((end-dragproportionx)<genomelength) {
					start=0;
					end=start+length;
				}
				else if ((start-dragproportionx)>0) {
					end=genomelength;
					start=end-length;
				}
			    myState.dragoffx = mx;
				myState.dragoffy = my;
				
				myState.valid = false; // Something's dragging so we must redraw
				return;
			}
		}, true);
		
		
		function MouseScroll (e) {
			
			e.preventDefault();
			var mouse = myState.getMouse(e);
			var mx = mouse.x;
			var my = mouse.y;
		    var mousex = mx - canvas.offsetLeft;
		    var mousey = my - canvas.offsetTop;
			
			var delta = 0;
			
			
	        if (!e){ /* For IE. */
	            e = window.event;
	        }
	        if (e.wheelDelta) { /* IE/Opera. */
	                delta = e.wheelDelta/120;
	        } 
	        else if (e.detail) { /** Mozilla case. */
	                /** In Mozilla, sign of delta is different than in IE.
	                 * Also, delta is multiple of 3.
	                 */
	                delta = -e.detail/3;
	        }
			
			if (delta>0){
				delta=1;	
			}
			else{
				delta=-1;	
			}
			
		    var zoom = 1 + delta/2;
		    if (delta>0) {
		    	scale-=scale/2;
		    }
		    else if (delta<0) {
		    	scale+=scale;	
		    }
			
			if (scale>1)	{
				scale=1	
			}
			else if (scale*genomelength<500)	{
				scale=500/genomelength	
			}
			
			if (mousex<canvasstart){
				mousex=canvasstart;
			}
			else if (mousex>canvasend){
				mousex=canvasend;
			}
			mousex-=canvasstart;
			
			var mouse_proportion_of_canvas=(mousex/canvaslength)
			var unzoomed_length=end-start
		    var mouse_genome_position=(mouse_proportion_of_canvas*unzoomed_length)+start;
		    
		    var zoomed_length=genomelength*scale;
		    
		    start=mouse_genome_position-(zoomed_length*mouse_proportion_of_canvas);
			
			end=mouse_genome_position+(zoomed_length*(1-mouse_proportion_of_canvas));
			
			if (start<0){
				start=0;
				end=zoomed_length;
			}
			else if (end>genomelength){
				end=genomelength;
				start=end-zoomed_length;
			}
		    
		    xscalingfactor=canvaslength/(end-start)

			myState.valid = false;
	
		}
		
		if (canvas.addEventListener) {    // all browsers except IE before version 9
                   // Internet Explorer, Opera, Google Chrome and Safari
               canvas.addEventListener ("mousewheel", MouseScroll, false);
                   // Firefox
               canvas.addEventListener ("DOMMouseScroll", MouseScroll, false);
           }
           else {
               if (canvas.attachEvent) { // IE before version 9
                   canvas.attachEvent ("onmousewheel", MouseScroll, false);
               }
           }
            
            
        var reader = new FileReader();
		reader.onload = function(event) {
		    var contents = event.target.result;
		    var lines = contents.split("\n");
		    var data_start=0;
		    var data_end=0;
		    var gubbins_data=[]
		    var reference_data=[]
		    for (i=0; i<lines.length; i++){
			    var words=lines[i].split("\t");
			    if (words[0][0]=="#"){
			    	var hwords=words[0].split(" ");
			    	if (hwords[0]=="##sequence-region") {
			    		data_start=parseInt(hwords[2])-1;
			    		data_end=parseInt(hwords[3]);
			    	}
			    }
			    else {
			    	if (words[1]=="GUBBINS"){
			    		gubbins_data.push([parseInt(words[3]),parseInt(words[4]), "red", 0.7, "red", 0, words[8]])	
			    	}
			    	else if (words[1]=="EMBL"){
			    		if (words[2]=="CDS"){
			    			reference_data.push([parseInt(words[3]),parseInt(words[4]), words[6], "#318DCC", "black", 1, words[8]])
			    		}
			    		else if (words[2]=="tRNA"){
			    			reference_data.push([parseInt(words[3]),parseInt(words[4]), words[6], "#53FFE9", "black", 1, words[8]])
			    		}
			    		else if (words[2]=="rRNA"){
			    			reference_data.push([parseInt(words[3]),parseInt(words[4]), words[6], "#6F8899", "black", 1, words[8]])
			    		}
			    		
			    		
			    		//featurestart, featureend, direction, fill, stroke, strokeWidth, name	
			    	}
			  	}
			 }
			 
			 start=data_start;
			 end=data_end;
			 genomelength=data_end-data_start;
			 xscalingfactor=canvaslength/(end-start)
			 if (gubbins_data.length>0) {
			 	recombinations=gubbins_data;
				 
				 myState.blocks = [];
				 for(recombinationnum = 0; recombinationnum < recombinations.length; recombinationnum++) {
					myState.blocks.push(new Block(recombinations[recombinationnum][0], recombinations[recombinationnum][1], recombinations[recombinationnum][2], recombinations[recombinationnum][3], recombinations[recombinationnum][4], recombinations[recombinationnum][5], recombinations[recombinationnum][6]));
				 }
				 
				 heatmap_blocks=ConvertBlockstoHeat(recombinations);
				 myState.heatblocks = [];
				 for(recombinationnum = 0; recombinationnum < heatmap_blocks.length; recombinationnum++) {
					myState.heatblocks.push(new Block(heatmap_blocks[recombinationnum][0],heatmap_blocks[recombinationnum][1],heatmap_blocks[recombinationnum][2]));
					
				}
				myState.depths=calculateBlockDepthPlot(myState.blocks);
			myState.valid = false;
			}
			
			if (reference_data.length>0) {
				 
				 myState.arrows = [];
				 for(recombinationnum = 0; recombinationnum < reference_data.length; recombinationnum++) {
					myState.arrows.push(new Arrow(reference_data[recombinationnum][0], reference_data[recombinationnum][1], reference_data[recombinationnum][2], reference_data[recombinationnum][3], reference_data[recombinationnum][4], reference_data[recombinationnum][5], reference_data[recombinationnum][6]));
					myState.valid = false;
				 }
			myState.valid = false;	 
			}
			
			
			
		}
		
		
		reader.onerror = function(event) {
		    console.error("File could not be read! Code " + event.target.error.code);
		};
		var target = document.getElementById("canvas");

		target.addEventListener("dragover", function(event) {
		    event.preventDefault();
		}, false);
		
		target.addEventListener("drop", function(event) {
		
		    // cancel default actions
		    event.preventDefault();
		
		    files = event.dataTransfer.files;
		    
		    if (files.length>1){
		    	alert("Error: Only one file can be uploaded at a time");
		    	return;	
		    }
			myfile=files[0]
			
		    console.log("Filename: " + myfile.name);
		    console.log("Type: " + myfile.type);
		    console.log("Size: " + myfile.size + " bytes");
		    
		    
			reader.readAsText(myfile);
		
		}, false);
            
		
		
		// **** Options! ****
		this.selectionColor = '#CC302E';
		this.selectionWidth = 2;
		this.interval = 30;
		setInterval(function() { myState.draw(); }, myState.interval);
		
		
	}

	
	
	
	CanvasState.prototype.addArrow = function(arrow) {
		this.arrows.push(arrow);
		//this.valid = false;
	}
	CanvasState.prototype.addBlock = function(block) {
		this.blocks.push(block);
		//this.valid = false;
	}
	CanvasState.prototype.clear = function() {
		this.ctx.clearRect(0, 0, this.width, this.height);
	}
	
	
	// While draw is called as often as the INTERVAL variable demands,
	// It only ever does something if the canvas gets invalidated by our code
	CanvasState.prototype.draw = function() {
		
		

		
		// if our state is invalid, redraw and validate!
		if (!this.valid) {
			
			
			
			
			var ctx = this.ctx;
			var arrows = this.arrows;
			var blocks = this.blocks;
			var heatblocks = this.heatblocks;
			var depths = this.depths;
			this.clear();
			// ** Add stuff you want drawn in the background all the time here **
			
			
			
			
			
			// draw all arrows
			var l = arrows.length;
			for (var i = 0; i < l; i++) {
				arrows[i].set_coordinates()
				var arrow = arrows[i];
				// We can skip the drawing of elements that have moved off the screen:
				if (arrow.x > this.width || arrow.y > this.height ||
				arrow.x + arrow.w < 0 || arrow.y + arrow.h < 0) continue;
				arrows[i].draw(ctx);
			}
			// draw selection
			// right now this is just a stroke along the edge of the selected Shape
			if (this.selection.length>0) {
				ctx.strokeStyle = this.selectionColor;
				ctx.lineWidth = this.selectionWidth;
				
				for (i=0; i<this.selection.length; i++){
					var mySel = this.selection[i];
					
					if (mySel.coordinates.length<2) {
						break;	
					}
					ctx.beginPath();
					ctx.moveTo(mySel.coordinates[0][0], mySel.coordinates[0][1]);
					for (var j = 0; j < mySel.coordinates.length; j++) {
						ctx.lineTo(mySel.coordinates[j][0], mySel.coordinates[j][1]);
					}
					ctx.closePath();
					ctx.stroke();
					ctx.fillStyle = "black";
					ctx.textBaseline="middle";
					ctx.textAlign = "center";
					ctx.font="12px Helvetica";
			  		ctx.fillText(mySel.ID, mySel.x+(mySel.w/2), scalepos-69);
			  		ctx.fillText(mySel.locus_tag, mySel.x+(mySel.w/2), scalepos-52);
			  		ctx.fillText(mySel.product, mySel.x+(mySel.w/2), scalepos-35);
				
				
				}
			}
			
			var l = blocks.length;
			for (var i = 0; i < l; i++) {
				blocks[i].set_xw()
				var block = blocks[i];
				// We can skip the drawing of elements that have moved off the screen:
				if (block.x > this.width || block.y > this.height ||
				block.x + block.w < 0 || block.y + block.h < 0) continue;
				ctx.save();
			    ctx.globalAlpha = block.fillAlpha;
				blocks[i].draw(ctx);
				ctx.restore();
			}
			
			var l = heatblocks.length;
			for (var i = 0; i < l; i++) {
				heatblocks[i].set_xw()
				heatblocks[i].y=200;
				var heatblock = heatblocks[i];
				// We can skip the drawing of elements that have moved off the screen:
				if (heatblock > this.width || heatblock.y > this.height ||
				heatblock.x + heatblock.w < 0 || heatblock.y + heatblock.h < 0) continue;
				heatblocks[i].draw(ctx);
			}
			
			// ** Add stuff you want drawn on top all the time here **
			if (genomelength>0){
				drawScale(ctx, canvasstart, canvasend);	
			}
			else {
				var imageObj = new Image();
	
				imageObj.onload = function() {
					s.ctx.drawImage(imageObj, canvas.width/2-imageObj.width/2, canvas.height/2-imageObj.height/2);
				};
				imageObj.src = "/Users/sh16/Desktop/canvas/Upload-Folder-Ash-icon.png"
			}
			
			if (blocks.length>0){
			
				drawBlockDepthPlot(ctx, depths)
			}
			
			this.valid = true;
		}
	}
	
	
	// Creates an object with x and y defined, set to the mouse position relative to the state's canvas
	// If you wanna be super-correct this can be tricky, we have to worry about padding and borders
	CanvasState.prototype.getMouse = function(e) {
		var element = this.canvas, offsetX = 0, offsetY = 0, mx, my;
		// Compute the total offset
		if (element.offsetParent !== undefined) {
			do {
				offsetX += element.offsetLeft;
				offsetY += element.offsetTop;
			} while ((element = element.offsetParent));
		}
		// Add padding and border style widths to offset
		// Also add the <html> offsets in case there's a position:fixed bar
		offsetX += this.stylePaddingLeft + this.styleBorderLeft + this.htmlLeft;
		offsetY += this.stylePaddingTop + this.styleBorderTop + this.htmlTop;
		mx = e.pageX - offsetX;
		my = e.pageY - offsetY;
		// We return a simple javascript object (a hash) with x and y defined
		return {x: mx, y: my};
	}
	
	// If you dont want to use <body onLoad='init()'>
	// You could uncomment this init() reference and place the script reference inside the body tag
	init();
	function init() {
		
		var s = new CanvasState(document.getElementById('canvas'));
		
		var imageObj = new Image();
	
		imageObj.onload = function() {
			s.ctx.drawImage(imageObj, canvas.width/2-imageObj.width/2, canvas.height/2-imageObj.height/2);
		};
		imageObj.src = "/Users/sh16/Desktop/canvas/Upload-Folder-Ash-icon.png"
		
		//var features = [[50, 60, "f", "red", "black", 1, "gene1"], [150, 300, "f", "red", "black", 1, "gene2"], [400, 700, "f", "cyan", "black", 1, "gene3"],[900,1700, "r", "blue", "black", 1, "gene4"],[3000,4500, "none", "green", "black", 1, "misc_feature1"], [2000,2900, "f", "yellow", "black", 1, "gene5"], [20000,29000, "f", "yellow", "black", 1, "gene6"], [18000,19000, "f", "yellow", "black", 1, "gene7"]]	;
		//for(featurenum = 0; featurenum < features.length; featurenum++) {
		//	s.addArrow(new Arrow(features[featurenum][0], features[featurenum][1], features[featurenum][2], features[featurenum][3], features[featurenum][4], features[featurenum][5], features[featurenum][6]));
		//}
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
		</script>
</body>
</html>	